<!doctype html>
<html lang="en">
<head>
  <script src="assets/three.min.js"></script>
  <script src="assets/three.js"></script>
<!--  <script src="assets/DDSLoader.js"></script>-->
<!--  <script src="assets/MTLLoader.js"></script>-->
  <script src="assets/OBJLoader.js"></script>
  <meta charset="utf-8">
  <title>Lss</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">

</head>

<body>
  <app-root></app-root>

<script src="assets/angular-1.7.9/angular.js"></script>
<script src="assets/jquery-1.11.0.js"></script>

<!--  c'n'p'm-->
  <script>
    var container;

    var camera, scene, renderer;

    var mouseX = 0, mouseY = 0;

    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;


    init();
    animate();


    function init() {

      container = document.createElement( 'div' );
      document.body.appendChild( container );

      camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
      camera.position.z = 10;

      // scene

      scene = new THREE.Scene();

      var ambient = new THREE.AmbientLight( 0x101030 );
      scene.add( ambient );

      var directionalLight = new THREE.DirectionalLight( 0xffeedd );
      directionalLight.position.set( 0, 0, 1 );
      scene.add( directionalLight );

      // texture

      var manager = new THREE.LoadingManager();
      manager.onProgress = function ( item, loaded, total ) {

        console.log( item, loaded, total );

      };

      var texture = new THREE.Texture();

      var onProgress = function ( xhr ) {
        if ( xhr.lengthComputable ) {
          var percentComplete = xhr.loaded / xhr.total * 100;
          console.log( Math.round(percentComplete, 2) + '% downloaded' );
        }
      };

      var onError = function ( xhr ) {
      };


      var loader = new THREE.ImageLoader( manager );
      loader.load( 'assets/waternormals.jpg', function ( image ) {

        texture.image = image;
        texture.needsUpdate = true;

      } );

      // model

      var loader = new THREE.OBJLoader( manager );
      loader.load( 'assets/tree.obj', function ( object ) {

        object.traverse( function ( child ) {

          if ( child instanceof THREE.Mesh ) {

            child.material.map = texture;

          }

        } );
        object.scale.x =  object.scale.y =  object.scale.z = 20;
        object.updateMatrix();
        object.position.y = -3;
        scene.add( object );

      }, onProgress, onError );

      //

      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio( window.devicePixelRatio );
      renderer.setSize( window.innerWidth, window.innerHeight );
      container.appendChild( renderer.domElement );

      document.addEventListener( 'mousemove', onDocumentMouseMove, false );

      //

      window.addEventListener( 'resize', onWindowResize, false );

    }

    function onWindowResize() {

      windowHalfX = window.innerWidth / 2;
      windowHalfY = window.innerHeight / 2;

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function onDocumentMouseMove( event ) {

      mouseX = ( event.clientX - windowHalfX ) / 2;
      mouseY = ( event.clientY - windowHalfY ) / 2;

    }

    //

    function animate() {

      requestAnimationFrame( animate );
      render();

    }

    function render() {

      camera.position.x += ( mouseX - camera.position.x ) * .5;
      camera.position.y += ( - mouseY - camera.position.y ) * .5;

      camera.lookAt( scene.position );

      renderer.render( scene, camera );

    }
    //声明raycaster和mouse变量
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();

    function onMouseClick( event ) {

      //通过鼠标点击的位置计算出raycaster所需要的点的位置，以屏幕中心为原点，值的范围为-1到1.

      mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
      mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

      // 通过鼠标点的位置和当前相机的矩阵计算出raycaster
      raycaster.setFromCamera( mouse, camera );

      console.log( scene.children);

      // 获取raycaster直线和所有模型相交的数组集合
      var intersects = raycaster.intersectObjects( scene.children[2].children );

      console.log(intersects);

      //将所有的相交的模型的颜色设置为红色，如果只需要将第一个触发事件，那就数组的第一个模型改变颜色即可
      for ( var i = 0; i < intersects.length; i++ ) {

        intersects[ i ].object.material.color.set( 0xff0000 );


      }

    }

    window.addEventListener( 'click', onMouseClick, false);
  </script>
  <div id="container">


  </div>
</body>
</html>
